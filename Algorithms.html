<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Algorithms</title>
	<link rel="stylesheet" href="css/common.css">

	<link rel="stylesheet" href="3dparty/highligthjs/styles/default.min.css">
	<script src="3dparty/highligthjs/highlight.min.js"></script>
	<script>hljs.highlightAll();</script>
</head>
<body>
	<a href="all.html">SiteMap</a>
	<div class="indent"></div>

	<table id="toc">
		<tr>
			<td></td>
			<td>
				<details open>
					<summary><h1>Sorting</h1></summary>
					<h2 class="margin-top-bottom-3">Comparison:</h2>
					<h3 class="padding-left-1em margin-top-bottom-3"><a href="#selection">Selection</a></h3>
					<h3 class="padding-left-1em margin-top-bottom-3"><a href="#bubble">Bubble</a></h3>
					<h3 class="padding-left-1em margin-top-bottom-3"><a href="#insertion">Insertion</a></h3>
					<h3 class="padding-left-1em margin-top-bottom-3"><a href="#merge">Merge</a></h3>
					<h3 class="padding-left-1em margin-top-bottom-3"><a href="#heap">Heap</a></h3>
					<h3 class="padding-left-1em margin-top-bottom-3"><a href="#quick">Quick</a></h3>
					<h2 class="margin-top-bottom-3">Non-Comparison:</h2>
				</details>
			</td>
		</tr>
	</table>

	<hr class="height2">

	<div id="selection">
		<h3 class="margin-bottom-3">Selection</h3>
		Time [Best <code class="back-pink border padding3">Ω(n²)</code>
		Average <code class="back-pink border padding3">Θ(n²)</code>
		Worst <code class="back-pink border padding3">O(n²)</code>]
		Space <small>Worst</small> [<code class="back-lime-green border padding3">O(1)</code>]<br>

		Stable <code class="back-pink border padding3">No</code>
		In-place <code class="back-lime-green border padding3">Yes</code><br>

		Find min/max and put it to the left, bit by bit, swapping<br>
		<pre><code class="language-java">        for (int i = 0; i < array.length - 1; i++) {
            int minIndex = i;
            for(int j = i + 1; j < array.length; j++) {
                if (array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }
            swap(array, i, minIndex);
        }</code></pre>
	</div>
	<hr>

	<div id="bubble">
		<h3 class="margin-bottom-3">Bubble</h3>
		Time [Best <code class="back-yellow border padding3">Ω(n)</code>
			Average <code class="back-pink border padding3">Θ(n²)</code>
			Worst <code class="back-pink border padding3">O(n²)</code>]
		Space <small>Worst</small> [<code class="back-lime-green border padding3">O(1)</code>]<br>

		Stable <code class="back-lime-green border padding3">Yes</code>
		In-place <code class="back-lime-green border padding3">Yes</code><br>

		Iterate array over and over, swaping adjacent elements until it sorted<br>
		<pre><code class="language-java">        while(!sorted) {
            sorted = true;
            for (int i = 0; i < array.length - 1 ; i++) {
                if (array[i] > array[i + 1]) {
                    swap(array, i, i + 1);
                    sorted = false;
                }
            }
        }</code></pre>
	</div>
	<hr>

	<div id="insertion">
		<h3 class="margin-bottom-3">Insertion</h3>
		Usage: Widely used for <small>small</small> data sets.<br>
		Time [Best <code class="back-yellow border padding3">Ω(n)</code>
		Average <code class="back-pink border padding3">Θ(n²)</code>
		Worst <code class="back-pink border padding3">O(n²)</code>]
		Space <small>Worst</small> [<code class="back-lime-green border padding3">O(1)</code>]<br>

		Stable <code class="back-lime-green border padding3">Yes</code>
		In-place <code class="back-lime-green border padding3">Yes</code><br>

		Consistently searches place where to insert current element.<br>
		<div style="height: 105px; overflow: hidden;">
			<img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="insertion">
		</div>
		<pre><code class="language-java">        for (int i = 1; i < array.length; i++) {
            int x = array[i];
            int j = i;
            for (; j > 0 && array[j-1] > x; j--) {
                array[j] = array[j-1];
            }
            array[j] = x;
        }</code></pre>
	</div>
	<hr>

	<div id="merge">
		<h3 class="margin-bottom-3">Merge</h3>

		Time [Best <code class="back-orange border padding3">Ω(n·log(n))</code>
		Average <code class="back-orange border padding3">Θ(n·log(n))</code>
		Worst <code class="back-orange border padding3">O(n·log(n))</code>]
		Space <small>Worst</small> [<code class="back-yellow border padding3">O(n)</code>]<br>

		Stable <code class="back-lime-green border padding3">Yes</code>
		In-place <code class="back-pink border padding3">No</code><br>

		<div class="indent4"></div>
		"Divide-and-conquer" approach. Divides array into arrays with 1 element in each,
		then comparing them and merging piece by piece.<br>
		Can be parallelized.<br>
		Ways: <em>Top-down</em> - recursive<small>(examples below)</small>. <em>Bottom-up</em> - iterative, non-recursive.<br>
		<img height="200px" src="https://upload.wikimedia.org/wikipedia/commons/e/e6/Merge_sort_algorithm_diagram.svg" alt="merge">
		<pre><code class="language-java">    int[] divideThenSortAndMerge(int[] array) {
        if (array.length > 1) {
            int mid = array.length / 2;
            int[] leftHalf = Arrays.copyOfRange(array, 0, mid);
            int[] rightHalf = Arrays.copyOfRange(array, mid, array.length);

            int[] sortedLeft = divideThenSortAndMerge(leftHalf);
            int[] sortedRight = divideThenSortAndMerge(rightHalf);

            array = sortAndMerge(sortedLeft, sortedRight);
        }
        return array;
    }

    int[] sortAndMerge(int[] left, int[] right) {
        int[] result = new int[left.length + right.length];
        int i = 0, j = 0, k = 0;

        while (i < left.length && j < right.length) {
            result[k++] = left[i] < right[j] ? left[i++] : right[j++]; // comparison is here
        }
        while (i < left.length) {
            result[k++] = left[i++];
        }
        while (j < right.length) {
            result[k++] = right[j++];
        }

        return result;
    }</code></pre>
	</div>
	<hr>

	<div id="heap">
		<h3 class="margin-bottom-3">Heap</h3>

		Time [Best <code class="back-orange border padding3">Ω(n·log(n))</code>
		Average <code class="back-orange border padding3">Θ(n·log(n))</code>
		Worst <code class="back-orange border padding3">O(n·log(n))</code>]
		Space <small>Worst</small> [<code class="back-lime-green border padding3">O(1)</code>]<br>

		Stable <code class="back-pink border padding3">No</code>
		In-place <code class="back-lime-green border padding3">Yes</code><br>

		<div class="indent4"></div>
		Based on <a href="ConnectedNotes.html#binaryHeap">Binary Heap</a>.<br>
		It views an input array as a <em>Binary Heap</em> from the start and performs self-balancing.<br>
		For array: <code class="code">6,4,9,2,5,8,10,1,3,7,6</code>, the initial heap is:<br>
		<img height="200px" src="svg/HeapSort.svg" alt="heap"><br>
		Phases:
		<ol class="margin-top-bottom-0">
			<li>Making the Max<small>(min)</small> heap</li>
			<li>Sorting the array by moving the max<small>(min)</small> elements to the end of array, consistently reducing the heap</li>
		</ol>
		<pre class="margin-top-0"><code class="language-java">    int[] heapSort(int[] array) {
        int n = array.length;

        // Build the "Max-heap"
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(array, n, i);
        }

        // The sorting: move the root(that is the max value) to the end of array,
        // consistently reducing the heap
        for (int i = n - 1; i > 0; i--) {
            swap(array, 0, i);
            heapify(array, i, 0);
        }

        return array;
    }

    void heapify(int[] array, int n, int root) {
        int largest = root;
        int left = 2 * root + 1;
        int right = 2 * root + 2;

        if (left < n && array[left] > array[largest]) {
            largest = left;
        }

        if (right < n && array[right] > array[largest]) {
            largest = right;
        }

        if (largest != root) {
            swap(array, root, largest);
            heapify(array, n, largest);
        }
    }</code></pre>

	</div>
	<hr>

	<div id="quick">
		<h3 class="margin-bottom-3">Quick</h3>

		Time [Best <code class="back-orange border padding3">Ω(n·log(n))</code>
		Average <code class="back-orange border padding3">Θ(n·log(n))</code>
		Worst <code class="back-pink border padding3">O(n²)</code>]
		Space <small>Worst</small> [<code class="back-light-green border padding3">O(log(n))</code>]<br>

		Stable <code class="back-pink border padding3">No</code>
		In-place <code class="back-lime-green border padding3">Yes</code><br>

		<div class="indent4"></div>
		"Divide-and-conquer" approach.
		It works by selecting a <em>pivot</em> element <small>from the array</small> and partitioning the other elements into two sub-arrays around the <em>pivot</em>.
		The <em>pivot</em> by default is taken from the last element, but can be chosen randomly.
		<div class="indent4"></div>
		Slightly faster than <a href="#merge">merge</a> sort and <a href="#heap">heapsort</a> for randomized data, particularly on larger distributions.

		<pre><code class="language-java">    // quickSortRange(array, 0, array.length - 1)
    static void quickSortRange(int[] array, int start, int end) {
        if (start < end) {
            int pivotIndex = makePartition(array, start, end);

            quickSortRange(array, start, pivotIndex - 1);
            quickSortRange(array, pivotIndex + 1, end);
        }
    }

    static int makePartition(int[] array, int start, int end) {
        int pivot = array[end];
        int i = start;

        for (int j = start; j < end; j++) {
            if (array[j] <= pivot) {
                swap(array, i++, j);
            }
        }

        swap(array, i, end);

        return i;
    }</code></pre>
	</div>
	<hr>

	<a href="all.html">SiteMap</a><br>
	<iframe class="footer" src="./footer.html"></iframe>
</body>
</html>